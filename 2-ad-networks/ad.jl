### A Pluto.jl notebook ###
# v0.12.4

using Markdown
using InteractiveUtils

# This Pluto notebook uses @bind for interactivity. When running this notebook outside of Pluto, the following 'mock version' of @bind gives bound variables a default value (instead of an error).
macro bind(def, element)
    quote
        local el = $(esc(element))
        global $(esc(def)) = Core.applicable(Base.get, el) ? Base.get(el) : missing
        el
    end
end

# ‚ïî‚ïê‚ï° acb3cc9c-12b4-11eb-1ea6-4f4fd21b7a71
begin
	using Pkg
	Pkg.add(["PlutoUI", "Plots", "ForwardDiff"])
	using Plots
	using PlutoUI
	using ForwardDiff
end

# ‚ïî‚ïê‚ï° 0521b3c8-12bb-11eb-20fd-c5abc540dcd2
html"<center><button onclick=present()>Activate supermagical presentation mode</button></center>"

# ‚ïî‚ïê‚ï° 49ab7f72-151c-11eb-2d99-2540c575e59e
md"""
$(html"<h1><center>Crash Course in VMC</h1></center>")
$(html"<h3><center>30 minutes of Automatic Differentiation</h3></center>")

$(html"<h4><center>(in Julia)</h4></center>")

$(html"<p><center> Filippo Vicentini</center></p><p><center> filippo.vicentini@epfl.ch</center></p>")
"""

# ‚ïî‚ïê‚ï° 88624a8c-151e-11eb-162f-81d8f91c1cb7
md"## Setup "

# ‚ïî‚ïê‚ï° c5619c64-151c-11eb-3953-7da3f7df89cb
md"""
This is a fancy, super-interactive notebook on Automatic Differentiation.

No netket here... :üò≠

If you are curious... How to run this notebook:

- Install Julia: see [https://julialang.org/downloads/](https://julialang.org/downloads/)
  - MacOs: üòä `brew cask install julia` üòä 
  - Linux: üò± Check https://julialang.org/downloads/platform/#linux_and_freebsd
    - don't use `apt intstall julia` unless you have recent distro
  - Don't tell Giuseppe

- Install dependencies (only the first time)
```
julia --project=. -e "using Pkg; Pkg.instantiate()" 
```

- Run the notebook
```
julia --project=. -e "using Pluto; Pluto.run()"
```

"""

# ‚ïî‚ïê‚ï° 0e96be80-1786-11eb-2cbc-b1560bcc7295
md"## Optimising a Cost function

A cost function is a _Scalar_ _real valued_ function

$\mathcal{C} : \mathbb{R}^N \rightarrow \mathbb{R}$

And to optimise it we usually need to compute it's gradient

$\vec\nabla\mathcal{C} : \mathbb{R}^N \rightarrow \mathbb{R}^N$
$\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mathcal{W}¬†\rightarrow \vec\nabla\mathcal{C}(\mathcal{W})$ 

"

# ‚ïî‚ïê‚ï° d7bd8802-1786-11eb-31aa-711b6ec57c69
md"""
## Gradients: the general case

Let's now consider a slightly more general case

$f : \mathbb{R}^{D_0} \rightarrow \mathbb{R}^{D_1}$


The first-order differential structure in the neighborhood of the point $x\in\mathbb{R}^{D_0}$ is encoded into the _Jacobian Matrix_

$\left(\mathcal{J}_{f}\right)^i_j(x) = \frac{(\partial f)^i}{\partial x^j}(x)$

Given another function 

$g : \mathbb{R}^{D_1} \rightarrow \mathbb{R}^{D_2}$

the Jacobian matrix for the composed function $h = g\circ f : \mathbb{R}^{D_0}\rightarrow \mathbb{R}^{D_2}$ can be written as:

$\left(\mathcal{J}_{h}\right)^i_j(x) = \frac{(\partial g)^i}{\partial y^k}(f(x))\frac{(\partial f)^k}{\partial x^j}(x)$
$\left(\mathcal{J}_{h}\right)^i_j(x) = \left(\mathcal{J}_{g}\right)^i_k(f(x)) \left(\mathcal{J}_{f}\right)^k_j(x)$

This is the chain rule
"""

# ‚ïî‚ïê‚ï° 1764b466-12b0-11eb-25e2-df662ae5de48
md"""# Our objective: derivatives
In the following: How to compute the derivative of a function $f(x) : \mathbb{R} \rightarrow \mathbb{R}$ on a computer.

The derivative is defined as:

$f'(x) = \frac{df}{dx}(x) = \lim_{\delta\rightarrow 0}\frac{f(x+\delta) - f(x)}{\delta}$
"""

# ‚ïî‚ïê‚ï° 646dade6-12b0-11eb-08c2-fb699277970f
md"""
## Roundoff errors

The easiest way to compute the derivative is by taking a small $\delta$ and using the formula above. 

Choosing a good $\delta$ is hard:

  - if $\delta$ too big $\rightarrow$ wrong result because the formula is asymptotic

  - if $\delta$ too small $\rightarrow$ wrong result because of roundoff errors:

"""


# ‚ïî‚ïê‚ï° 4614c9c0-12b2-11eb-324e-d10bf3b788a1
md"If I take a random (flating-point) number around $10^{-10}$...

$(@bind __Œ¥exp Slider(-20:20, default=-10))"

# ‚ïî‚ïê‚ï° fb649acc-12b1-11eb-169d-7ffdc8438666
Œ¥ = rand()*10.0 ^(__Œ¥exp)

# ‚ïî‚ïê‚ï° 5be24bb0-12b2-11eb-0c9b-e9d432aed109
md"The _machine epsilon_ of $\delta$ is the smallest number we can add to Œ¥ and obtain a number different from Œ¥"

# ‚ïî‚ïê‚ï° 0947fa56-12b2-11eb-3559-679b852517a6
eps(Œ¥)

# ‚ïî‚ïê‚ï° fc1cfad0-12b2-11eb-1312-f524f61fd631
md"Usually with double precision (8 byte) floating point number we have 16 digits of precision ($25 - 10 \approx 16$) in the *low* digits."

# ‚ïî‚ïê‚ï° 22693a08-12b2-11eb-0cc7-ef5ca4fca5ff
Œ¥‚ÇÇ = 1 + Œ¥

# ‚ïî‚ïê‚ï° fa39648c-12b3-11eb-0273-2d3c723d49ad
md"You see that now $Œ¥‚ÇÇ$ has lost information about the lowest digits of $Œ¥$, because it's accurate only up to the 16-th digit."

# ‚ïî‚ïê‚ï° 2d4c133a-12b2-11eb-2e35-abb596e8bd84
eps(Œ¥‚ÇÇ)

# ‚ïî‚ïê‚ï° e3404d00-151e-11eb-0401-7307e3780834
Œ¥ÃÉ = Œ¥‚ÇÇ - 1

# ‚ïî‚ïê‚ï° 62e89888-12bc-11eb-133e-911baa5701bc
md"## Finite Differencing 

So if i consider the simple function:"

# ‚ïî‚ïê‚ï° 73162d24-12b4-11eb-15a6-079db4539ba9
f(x) = exp(x) + sin(x);

# ‚ïî‚ïê‚ï° 892c68ee-12bc-11eb-36bb-5f72dec05239
md"and it's analytical derivative:"

# ‚ïî‚ïê‚ï° 5c7c1c24-12b5-11eb-0b5b-47016c08ceb9
dfdx(x) = exp(x) + cos(x);

# ‚ïî‚ïê‚ï° 84cde1a0-12b8-11eb-24a6-c72179eb1821
diff_error(diff_fun, x, Œ¥) = abs.(diff_fun.(f, x, Œ¥) .- dfdx(x));

# ‚ïî‚ïê‚ï° 83bd9c62-12b4-11eb-2fd9-577321bfd8eb
forward_difference(f, x, Œ¥) = (f(x+Œ¥) - f(x))/Œ¥; 

# ‚ïî‚ïê‚ï° a8a48c20-12b4-11eb-22fc-39bafed06616
# I first compute the exact values using Arbitrary precision arithmetics
Œ¥_arr = 10 .^ (range(-16, 0, length=100))

# ‚ïî‚ïê‚ï° d6e6d412-1531-11eb-19c9-e9ec766dcddc
md"I select a point x‚ÇÄ in it's domain and compute the derivative there: $...

$(@bind x‚ÇÄ Slider(-1:0.01:1, default=0.3))
"


# ‚ïî‚ïê‚ï° 2cb2439a-1532-11eb-2cc4-ef25533e9747
md"x‚ÇÄ =$x‚ÇÄ"

# ‚ïî‚ïê‚ï° 6124c9f0-12b6-11eb-1cfd-2fa0a8073c57
œµ_fwd = diff_error(forward_difference, x‚ÇÄ, Œ¥_arr)

# ‚ïî‚ïê‚ï° 422fcb0c-12b5-11eb-35d1-2939fcef5e31
pl = plot(Œ¥_arr, œµ_fwd, xscale=:log10, yscale=:log10, label="forward difference",  xlabel="step Œ¥", ylabel="error œµ")

# ‚ïî‚ïê‚ï° a2eb5c90-12bc-11eb-253c-cdb93e5d9634
md"## Finite Differencing: take 2

Instead of using the forward differencing formula, we can use more accurate central difference:"

# ‚ïî‚ïê‚ï° 8b6d33c2-12b5-11eb-160d-650dbb5da796
central_difference(f, x, Œ¥) = (f(x+Œ¥) - f(x-Œ¥))/2Œ¥;

# ‚ïî‚ïê‚ï° 97ecb6e6-12b6-11eb-1e25-25bad787aa96
œµ_cnt = diff_error(central_difference, x‚ÇÄ, Œ¥_arr)

# ‚ïî‚ïê‚ï° 832609d8-12b6-11eb-06a4-17a58dd35a9b
pl2 = plot!(deepcopy(pl), Œ¥_arr, œµ_cnt, xscale=:log10, yscale=:log10, label="central difference")

# ‚ïî‚ïê‚ï° 32b8deea-12b7-11eb-2f14-0565a9db5882
md"And this slope also depends on the function that we are evaluating..."

# ‚ïî‚ïê‚ï° 8094bf72-12b7-11eb-02d6-a365f76bcb92
md"""
## Algebraic Approach: Complex step 


The problem with finite differencing is that we are mixing our really small number with the really large number, and so when we do the subtract we lose accuracy.

* We want to keep the perturbation (f'(x)) and the value (f(x)) completely separate 
"""

# ‚ïî‚ïê‚ï° d9100e2e-12b7-11eb-1ee2-6949a38abcd1
md"$f(x + i\delta) = f(x) + f'(x) i \delta + \mathcal{O}(\delta^2)$"

# ‚ïî‚ïê‚ï° 058ff8f6-12b8-11eb-2f97-d59c4fc7517a
md"$if'(x) = \frac{f(x + iŒ¥) - f(x)}{\delta} + \mathcal{O}(\delta)$"

# ‚ïî‚ïê‚ï° 3c22b5c0-12b8-11eb-3cf0-1b5a0755450b
md"If $x$ is real and $f$ is real-valued then $if'$ is purely imaginary, therefore by taking the imaginary part of the lhs and rhs..."

# ‚ïî‚ïê‚ï° 2e2cd25c-12b8-11eb-0985-6de4c6fedc94
md"$f'(x) = \frac{\Im[f(x + iŒ¥) + 0]}{\delta} + \mathcal{O}(\delta)$"

# ‚ïî‚ïê‚ï° 75e37722-12b8-11eb-2d73-691b4aa1634a
md"Let's try this approach:"

# ‚ïî‚ïê‚ï° 7a928a1a-12b8-11eb-2722-a96569ef6407
complex_difference(f, x, Œ¥) = imag(f(x+im*Œ¥)/Œ¥)

# ‚ïî‚ïê‚ï° c1629480-12b8-11eb-1fb9-c3a4ff1e63d2
œµ_cmplx = diff_error(complex_difference, x‚ÇÄ, Œ¥_arr) .+ eps(Float64)

# ‚ïî‚ïê‚ï° d11c2ac6-12b8-11eb-30cb-8109d0a36300
pl3 = plot!(pl2, Œ¥_arr, œµ_cmplx, xscale=:log10, yscale=:log10, label="complex step")

# ‚ïî‚ïê‚ï° 6544e846-12b9-11eb-1ea1-8f37a7d315f3
md"WOW! practically 0 error!

This is because f is a real function of real inputs, and the step $iŒ¥$ is purely imaginary, so the real and imaginary part never mix! 

No mixing $\rightarrow$ no numerical cancellation and roundoff errors!
"

# ‚ïî‚ïê‚ï° d8e75d86-12b9-11eb-01d0-451c26fdf2ed
md"""
### Generalizing: Sensitivities and Dual numbers

The derivative can be thought as the sensitivity of a function to it's input:

	how much does f(x‚ÇÄ) changes when the input x‚ÇÄ changes by a small amount Œ¥?

Thanks to the Taylor's theorem:

$f(x_0+\delta) = f(x_0) + \delta f'(x_0) + ...$

And now, think about the $\delta$ as a component (a bit like the $i$ unit, quaternion directions $i,j,k$, grassman $\epsilon$...)

$\mathbb{D}(\mathbb{R}) \sim \mathbb{R}\times\mathbb{R}$

$a\in\mathbb{D}(\mathbb{R}) = a_{value} + \delta a_{sensitivity}$

$f : \mathbb{D}(\mathbb{R}) \rightarrow \mathbb{D}(\mathbb{R})$
$f(a) = f(a) + \delta f'(a)$ 

$a + b = (a_v + b_v) + \delta ( a_s + b_s)$
$a b = (a_v  b_v) + \delta ( a_s  b_v + a_v  b_s)$

"""

# ‚ïî‚ïê‚ï° 4830a0bc-12d0-11eb-250b-8fd51130ef12
struct Dual{T}
	val::T
	sen::T
end

# ‚ïî‚ïê‚ï° 49e434e6-12d0-11eb-0d5c-c1befca3ed92
Base.:+(f::Dual, g::Dual) = Dual(f.val + g.val, f.sen + g.sen)

# ‚ïî‚ïê‚ï° a7294eb4-12d2-11eb-0751-892ee34934c6
Base.:+(f::Dual, Œ±::Number) = Dual(f.val + Œ±, f.sen)

# ‚ïî‚ïê‚ï° a78da71a-12d2-11eb-12d1-83a0d0fc6d15
Base.:+(Œ±::Number, f::Dual) = f + Œ±

# ‚ïî‚ïê‚ï° b5bd2d70-12e5-11eb-2a70-176997854b11
Base.:*(f::Dual, g::Dual) = Dual(f.val*g.val, f.sen*g.val + f.val*g.sen)

# ‚ïî‚ïê‚ï° a05bf786-12e5-11eb-0aff-1358f8a0d23f
Base.exp(f::Dual) = Dual(exp(f.val), exp(f.val) * f.sen)

# ‚ïî‚ïê‚ï° 7967d372-1789-11eb-092c-07226f7c3a2e
Base.log(f::Dual) = Dual(exp(f.val), inv(f.val) * f.sen)

# ‚ïî‚ïê‚ï° 3a8b83f2-1387-11eb-1edf-75541c38c98d
Base.sin(f::Dual) = Dual(sin(f.val), cos(f.val) * f.sen)

# ‚ïî‚ïê‚ï° d5d8a97a-12e5-11eb-283e-e7ac4613e43c
f(Dual(x‚ÇÄ,1.0)).sen

# ‚ïî‚ïê‚ï° 301e3eb6-1387-11eb-0190-2931daf82f1a
dfdx(x‚ÇÄ)

# ‚ïî‚ïê‚ï° 888a9050-1532-11eb-1823-c327dd8d6834
md"""
However, think about the function
"""

# ‚ïî‚ïê‚ï° f7a98b50-1788-11eb-30d0-a163d703e1fd
md"""
##¬†An example

A nested function 

"""

# ‚ïî‚ïê‚ï° 0ccf3c6e-1789-11eb-03ff-dd75fff32410
h = exp ‚àò sin ‚àò log

# ‚ïî‚ïê‚ï° 206bbb3a-1789-11eb-3c83-15d41dcd4d23
plot(range(0.01, 3.0, length=100), h)

# ‚ïî‚ïê‚ï° 51bbba96-1789-11eb-218e-ebc94527410a
#¬†Forward mode:
x·µ¢ = Dual(0.5, 1.0)

# ‚ïî‚ïê‚ï° 62dcd53a-1789-11eb-13f3-39d907a8ba76
y‚ÇÅ = log(x·µ¢)

# ‚ïî‚ïê‚ï° 9e845f9a-1789-11eb-1760-59dfdf42d6e5
y‚ÇÇ = sin(y‚ÇÅ)

# ‚ïî‚ïê‚ï° b9982c44-1789-11eb-3c11-31655a8c77cf
y‚ÇÉ = sin(y‚ÇÇ)

# ‚ïî‚ïê‚ï° Cell order:
# ‚ïü‚îÄ0521b3c8-12bb-11eb-20fd-c5abc540dcd2
# ‚ïü‚îÄ49ab7f72-151c-11eb-2d99-2540c575e59e
# ‚ïü‚îÄ88624a8c-151e-11eb-162f-81d8f91c1cb7
# ‚ïü‚îÄc5619c64-151c-11eb-3953-7da3f7df89cb
# ‚ï†‚ïêacb3cc9c-12b4-11eb-1ea6-4f4fd21b7a71
# ‚ï†‚ïê0e96be80-1786-11eb-2cbc-b1560bcc7295
# ‚ïü‚îÄd7bd8802-1786-11eb-31aa-711b6ec57c69
# ‚ï†‚ïê1764b466-12b0-11eb-25e2-df662ae5de48
# ‚ïü‚îÄ646dade6-12b0-11eb-08c2-fb699277970f
# ‚ïü‚îÄ4614c9c0-12b2-11eb-324e-d10bf3b788a1
# ‚ïü‚îÄfb649acc-12b1-11eb-169d-7ffdc8438666
# ‚ïü‚îÄ5be24bb0-12b2-11eb-0c9b-e9d432aed109
# ‚ï†‚ïê0947fa56-12b2-11eb-3559-679b852517a6
# ‚ïü‚îÄfc1cfad0-12b2-11eb-1312-f524f61fd631
# ‚ï†‚ïê22693a08-12b2-11eb-0cc7-ef5ca4fca5ff
# ‚ïü‚îÄfa39648c-12b3-11eb-0273-2d3c723d49ad
# ‚ï†‚ïê2d4c133a-12b2-11eb-2e35-abb596e8bd84
# ‚ï†‚ïêe3404d00-151e-11eb-0401-7307e3780834
# ‚ïü‚îÄ84cde1a0-12b8-11eb-24a6-c72179eb1821
# ‚ïü‚îÄ62e89888-12bc-11eb-133e-911baa5701bc
# ‚ï†‚ïê73162d24-12b4-11eb-15a6-079db4539ba9
# ‚ïü‚îÄ892c68ee-12bc-11eb-36bb-5f72dec05239
# ‚ï†‚ïê5c7c1c24-12b5-11eb-0b5b-47016c08ceb9
# ‚ï†‚ïê83bd9c62-12b4-11eb-2fd9-577321bfd8eb
# ‚ï†‚ïêa8a48c20-12b4-11eb-22fc-39bafed06616
# ‚ïü‚îÄd6e6d412-1531-11eb-19c9-e9ec766dcddc
# ‚ïü‚îÄ2cb2439a-1532-11eb-2cc4-ef25533e9747
# ‚ï†‚ïê6124c9f0-12b6-11eb-1cfd-2fa0a8073c57
# ‚ï†‚ïê422fcb0c-12b5-11eb-35d1-2939fcef5e31
# ‚ïü‚îÄa2eb5c90-12bc-11eb-253c-cdb93e5d9634
# ‚ï†‚ïê8b6d33c2-12b5-11eb-160d-650dbb5da796
# ‚ï†‚ïê97ecb6e6-12b6-11eb-1e25-25bad787aa96
# ‚ï†‚ïê832609d8-12b6-11eb-06a4-17a58dd35a9b
# ‚ïü‚îÄ32b8deea-12b7-11eb-2f14-0565a9db5882
# ‚ïü‚îÄ8094bf72-12b7-11eb-02d6-a365f76bcb92
# ‚ïü‚îÄd9100e2e-12b7-11eb-1ee2-6949a38abcd1
# ‚ïü‚îÄ058ff8f6-12b8-11eb-2f97-d59c4fc7517a
# ‚ïü‚îÄ3c22b5c0-12b8-11eb-3cf0-1b5a0755450b
# ‚ïü‚îÄ2e2cd25c-12b8-11eb-0985-6de4c6fedc94
# ‚ïü‚îÄ75e37722-12b8-11eb-2d73-691b4aa1634a
# ‚ï†‚ïê7a928a1a-12b8-11eb-2722-a96569ef6407
# ‚ï†‚ïêc1629480-12b8-11eb-1fb9-c3a4ff1e63d2
# ‚ï†‚ïêd11c2ac6-12b8-11eb-30cb-8109d0a36300
# ‚ïü‚îÄ6544e846-12b9-11eb-1ea1-8f37a7d315f3
# ‚ïü‚îÄd8e75d86-12b9-11eb-01d0-451c26fdf2ed
# ‚ï†‚ïê4830a0bc-12d0-11eb-250b-8fd51130ef12
# ‚ï†‚ïê49e434e6-12d0-11eb-0d5c-c1befca3ed92
# ‚ï†‚ïêa7294eb4-12d2-11eb-0751-892ee34934c6
# ‚ï†‚ïêa78da71a-12d2-11eb-12d1-83a0d0fc6d15
# ‚ï†‚ïêb5bd2d70-12e5-11eb-2a70-176997854b11
# ‚ï†‚ïêa05bf786-12e5-11eb-0aff-1358f8a0d23f
# ‚ï†‚ïê7967d372-1789-11eb-092c-07226f7c3a2e
# ‚ï†‚ïê3a8b83f2-1387-11eb-1edf-75541c38c98d
# ‚ï†‚ïêd5d8a97a-12e5-11eb-283e-e7ac4613e43c
# ‚ï†‚ïê301e3eb6-1387-11eb-0190-2931daf82f1a
# ‚ï†‚ïê888a9050-1532-11eb-1823-c327dd8d6834
# ‚ïü‚îÄf7a98b50-1788-11eb-30d0-a163d703e1fd
# ‚ï†‚ïê0ccf3c6e-1789-11eb-03ff-dd75fff32410
# ‚ï†‚ïê206bbb3a-1789-11eb-3c83-15d41dcd4d23
# ‚ï†‚ïê51bbba96-1789-11eb-218e-ebc94527410a
# ‚ï†‚ïê62dcd53a-1789-11eb-13f3-39d907a8ba76
# ‚ï†‚ïê9e845f9a-1789-11eb-1760-59dfdf42d6e5
# ‚ï†‚ïêb9982c44-1789-11eb-3c11-31655a8c77cf
